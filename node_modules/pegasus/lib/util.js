var iconv = require('iconv-lite'),
	nativeUtil = require('util');

/**
 * Test whether type of input value is Array.
 * @param value {*}
 * @return {boolean}
 */
var isArray = exports.isArray = nativeUtil.isArray;

/**
 * Test whether type of input value is Boolean.
 * @param value {*}
 * @return {boolean}
 */
var isBoolean = exports.isBoolean = function (value) {
	return typeof value === 'boolean';
};

/**
 * Test whether type of input value is Buffer.
 * @param value {*}
 * @return {boolean}
 */
var isBuffer = exports.isBuffer = function (value) {
	return value instanceof Buffer;
};

/**
 * Test whether type of input value is Date.
 * @param value {*}
 * @return {boolean}
 */
var isDate = exports.isDate = nativeUtil.isDate;

/**
 * Test whether type of input value is Error.
 * @param value {*}
 * @return {boolean}
 */
var isError = exports.isError = nativeUtil.isError;

/**
 * Test whether type of input value is Function.
 * @param value {*}
 * @return {boolean}
 */
var isFunction = exports.isFunction = function (value) {
	return typeof value === 'function';
};

/**
 * Test whether type of input value is Null.
 * @param value {*}
 * @return {boolean}
 */
var isNull = exports.isNull = function (value) {
	return value === null;
};

/**
 * Test whether type of input value is Number.
 * @param value {*}
 * @return {boolean}
 */
var isNumber = exports.isNumber = function (value) {
	return typeof value === 'number' && isFinite(value);
};

/**
 * Test whether type of input value is Object.
 * @param value {*}
 * @return {boolean}
 */
var isObject = exports.isObject = function (value) {
	return value === Object(value);
};

/**
 * Test whether type of input value is RegExp.
 * @param value {*}
 * @return {boolean}
 */
var isRegExp = exports.isRegExp = nativeUtil.isRegExp;

/**
 * Test whether type of input value is String.
 * @param value {*}
 * @return {boolean}
 */
var isString = exports.isString = function (value) {
	return typeof value === 'string';
};

/**
 * Test whether type of input value is Undefined.
 * @param value {*}
 * @return {boolean}
 */
var isUndefined = exports.isUndefined = function(value) {
	return typeof value === 'undefined';
};

/**
 * Convert array-like object to array.
 * @param value {*}
 * @return {boolean}
 */
var toArray = exports.toArray = (function () {
	var slice = Array.prototype.slice;

	return function (obj) {
		return slice.call(obj);
	};
}());

/**
 * Get type of input value.
 * Copyright 2011 Yahoo! Inc. All rights reserved.
 * @param value {*}
 * @return {string}
 */
var type = exports.type = (function () {
	var TYPES = {
			'undefined'        : 'undefined',
			'number'           : 'number',
			'boolean'          : 'boolean',
			'string'           : 'string',
			'[object Function]': 'function',
			'[object RegExp]'  : 'regexp',
			'[object Array]'   : 'array',
			'[object Date]'    : 'date',
			'[object Error]'   : 'error'
		},
		toString = Object.prototype.toString;

	return function (value) {
		return TYPES[typeof value]
			|| TYPES[toString.call(value)]
			|| (value ? 'object' : 'null');
	};
}());

/**
 * Create a child constructor.
 * @param parent {Function}
 * @param prototype {Object}
 * @return {Function}
 */
var inherit = exports.inherit = function (parent, prototype) {
	var ctor = function () {
			if (isFunction(this._initialize)) {
				return this._initialize.apply(this, arguments);
			}
		};

	prototype.__proto__ = parent.prototype;

	Object.defineProperty(prototype, 'constructor', {
		enumerable: false,
		value: ctor
	});

	ctor.prototype = prototype;
	ctor.superclass = parent.prototype;
	ctor.extend = inherit.bind(null, ctor);

	return ctor;
};

/**
 * Shallow copy properties from souce object to target object.
 * @param target {Object}
 * @param source {Object+}
 * @param [overwrite] {boolean}
 * @return {Object}
 */
var mix = exports.mix = function () {
	var args = toArray(arguments),
		target = args.shift() || {},
		overwrite = isBoolean(args[args.length - 1]) ? args.pop() : true,
		i, len1, source, arr, key, j, len2;

	for (i = 0, len1 = args.length; i < len1; ++i) {
		if (source = args[i]) { // Assign
			arr = keys(source);
			for (j = 0, len2 = arr.length; j < len2; ++j) {
				key = arr[j];
				if (!target.hasOwnProperty(key) || overwrite) {
					target[key] = source[key];
				}
			}
		}
	}

	return target;
};

/**
 * Shallow copy properties from souce object to new-created empty object.
 * @param source {Object+}
 * @param [overwrite] {boolean}
 * @return {Object}
 */
var merge = exports.merge = function () {
	var args = toArray(arguments);

	args.unshift({});

	return mix.apply(null, args);
};

/**
 * Iterate key-value pair in object or array.
 * @param obj {Object}
 * @param iterator {Function}
 * @param context {Object}
 */
var each = exports.each = function (obj, iterator, context) {
	var arr = keys(obj),
		len = arr.length,
		i = 0,
		key;

	for (; i < len; ++i) {
		key = arr[i];
		iterator.call(context || null, obj[key], key, obj);
	}
};

/**
 * Get keys of an object.
 * @param obj {Object}
 * @return {Array}
 */
var keys = exports.keys = Object.keys;

/**
 * Get values of an object.
 * @param obj {Object}
 * @return {Array}
 */
var values = exports.values = function (obj) {
	var result = [];

	each(obj, function (value) {
		result.push(value);
	});

	return result;
};

/**
 * Convert string to binary using specified charset.
 * @param str {string}
 * @param charset {string}
 * @return {Buffer}
 */
var encode = exports.encode = iconv.encode;

/**
 * Convert binary to string using specified charset.
 * @param bin {Buffer}
 * @param charset {string}
 * @return {string}
 */
var decode = exports.decode = iconv.decode;

/**
 * Bind a generator with the runner.
 * @param generator {Function*}
 * @return {Function}
 */
var g = exports.g = (function () {
	function run(f, c) {
		(function next(err, data) {
			try {
				if (err) {
					f.throw(err);
				} else {
					var ret = f.next(data);
					if (!ret.done) {
						ret.value(next);
					} else {
						c(null, ret.value);
					}
				}
			} catch (err) {
				c(err);
			}
		}());
	}
	
	return function (generator) {
		return function () {
			var args = toArray(arguments),
				c = args.pop(),
				f = generator.apply(this, args);
				
			run(f, c);
		};
	};
}());