var util = require('./util'),
	version = require('./version'),
	Request = require('./request'),
	Response = require('./response'),
	Router = require('./router');

var PATTERN_FIRST_LETTER = /^\w|-\w/g;

/**
 * Convert { "foo-bar": "" } to { "Foo-Bar": "" }.
 * @param obj {Object}
 * @return {Object}
 */
function refine(obj) {
	var output = {};

	util.each(obj, function (value, key) {
		if (value) {
			key = key.replace(PATTERN_FIRST_LETTER, function ($0) {
				return $0.toUpperCase();
			});
			output[key] = value;
		}
	});

	return output;
}

/**
 * HTTP listener factory.
 * @param options {Object}
 * @return {Function}
 */
function create(options) {
	var charset = options.charset,
		detailedError = options.detailedError,
		maxRequestLength = options.maxRequestLength,
		
		// Router instance.
		router = new Router();

	function listener(request, response, callback) {
		var data = [],
			length = 0,
			i = 2,
			req, res;

		(function next(err) {
			if (err) {
				response.writeHead(500);
				response.end(detailedError ? err.stack : '');
				
				if (callback) {
					callback(err);
				}
			} else {
				switch (i--) {
				case 2: /* Collect all the request datum. */
					request.on('data', function (chunk) {
						length += chunk.length;
						if (length > maxRequestLength) {
							// Stop receiving data.
							request.destroy();
							err = new Error('Request size limit reached');
						} else {
							data.push(chunk);
						}
					});

					request.on('end', function () {
						next(err);
					});
					break;
				case 1: /* Create the virtual request and response. */
					var protocol = request.connection.encrypted
							? 'https:' : 'http:',
						url = protocol + '//' + request.headers.host
							+ request.url;

					try { // The URL might be malformed.
						url = decodeURI(url);
					} catch (e) {
						err = e;
					}

					if (err) {
						next(err);
					} else {
						req = new Request({
							url: url,
							method: request.method,
							ip: request.client.remoteAddress,
							headers: request.headers,
							data: Buffer.concat(data, length),
							charset: charset
						});
							
						res = new Response({
							charset: charset
						});
						
						router.route(req, res, next);
					}

					break;
				case 0: /* Response to the client. */
					var status = res.status(),
						headers = refine(res.head()),
						body = res._data,
						len = body.length,
						j = 0;

					// Set content-length to the right value.
					headers['Content-Length'] = res._length;

					/* RFC2616: HEAD request, 1xx(informational),
					   204(no content), 304(not modified)
					   response MUST NOT include a message-body.
					   NodeJS will take care of this,
					   so we DO NOT implement this by ourself. */
					response.writeHead(status, headers);
					
					for (; j < len; ++j) {
						response.write(body[j]);
					}
					
					response.end();
					
					if (callback) {
						callback(null);
					}
				}
			}
		}());
	}

	// Bridge the mount method.
	listener.mount = function () {
		router.mount.apply(router, arguments);
		return listener;
	};

	return listener;
}

exports.create = create;
